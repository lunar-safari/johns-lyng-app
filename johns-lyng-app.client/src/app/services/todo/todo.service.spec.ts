import { TestBed } from '@angular/core/testing';
import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';
import { TodoDataService } from './todo-data.service';
import { TodoItem } from '../../interfaces/todo.interface';

describe('TodoDataService', () => {
  let service: TodoDataService;
  let httpMock: HttpTestingController;

  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      providers: [TodoDataService]
    });
    service = TestBed.inject(TodoDataService);
    httpMock = TestBed.inject(HttpTestingController);
  });

  afterEach(() => {
    httpMock.verify();
  });

  it('getItems should return an Observable<TodoItem[]>', () => {
    const mockTodoItems: TodoItem[] = [{ id: '12345', description: 'Test Todo', isCompleted: false }];

    service.getItems().subscribe(items => {
      expect(items.length).toBe(1);
      expect(items).toEqual(mockTodoItems);
    });

    const req = httpMock.expectOne(service.baseUrl);
    expect(req.request.method).toBe('GET');
    req.flush(mockTodoItems);
  });


  // Test for addItem method in TodoDataService

  it('addItem should generate a unique ID for each new todo item', () => {
    const description = 'Unique ID Todo';
    service.addItem(description).subscribe(response => {
      expect(response.id).toBeDefined();
      expect(typeof response.id).toBe('string');
      expect(response.description).toEqual(description);
      expect(response.isCompleted).toBeFalse();
    });

    // Match the outgoing request to addItem
    const req = httpMock.expectOne('https://localhost:44397/api/TodoItems');
    expect(req.request.method).toBe('POST');
    // Respond with mock data, simulating a successful POST request
    req.flush({
      id: '123', // Simulate a unique ID generated by the server
      description: description,
      isCompleted: false
    });

  });

  it('addItem should send a POST request with correct body', () => {
    const description = 'Todo with correct body';
    service.addItem(description).subscribe();

    const req = httpMock.expectOne(service.baseUrl);
    expect(req.request.method).toBe('POST');
    expect(req.request.body.description).toEqual(description);
    expect(req.request.body.isCompleted).toBeFalse();
    expect(req.request.body.id).toBeDefined();
    expect(typeof req.request.body.id).toBe('string');

    // Simulate a response that echoes back the posted item, including the generated ID
    req.flush(req.request.body);
  });


  it('addItem should not allow empty descriptions', () => {
    const description = ''; // Empty description
    service.addItem(description).subscribe(
      response => fail('Expected an error for empty description, but got a response'),
      error => expect(error).toBeTruthy() // Expect some error response
    );

    const req = httpMock.expectOne(service.baseUrl);
    expect(req.request.method).toBe('POST');
    // Expect the request body to have an empty description, which should be handled by the server or service
    expect(req.request.body.description).toEqual(description);
    // Simulate a response indicating a bad request due to empty description
    req.flush({ message: 'Description cannot be empty' }, { status: 400, statusText: 'Bad Request' });
  });


  it('markAsComplete should update the item and return the response', () => {
    const todoItem: TodoItem = { id: '123456', description: 'Existing Todo', isCompleted: false };
    const updatedItem = { ...todoItem, isCompleted: true };

    service.markAsComplete(todoItem).subscribe(response => {
      expect(response).toEqual(updatedItem);
    });

    const req = httpMock.expectOne(`${service.baseUrl}/${todoItem.id}`);
    expect(req.request.method).toBe('PUT');
    expect(req.request.body).toEqual(updatedItem);
    req.flush(updatedItem);
  });
});
